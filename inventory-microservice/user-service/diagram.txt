USER-SERVICE PROJECT ARCHITECTURE & FLOW DIAGRAM
=================================================

PROJECT OVERVIEW:
-----------------
This is a Go-based microservice for user management and authentication using JWT tokens,
built with Gin web framework and PostgreSQL database.

PROJECT STRUCTURE:
------------------
user-service/
├── main.go                           # Application entry point
├── handlers/                         # HTTP request handlers
│   ├── handlers.go                   # Route registration
│   └── users.go                      # User-specific handlers (SignUp, Login)
├── internal/                         # Internal packages
│   ├── auth/                         # JWT authentication logic
│   │   └── auth.go                   # Token generation/validation
│   ├── users/                        # User business logic
│   │   ├── users.go                  # User operations (CRUD)
│   │   └── models.go                 # User data structures
│   └── stores/postgres/              # Database layer
│       ├── db.go                     # Database connection & migrations
│       └── migrations/               # Database schema migrations
├── exp/                              # Experimental/example code
│   ├── creating-jwt-token/           # JWT token creation examples
│   └── verify-token/                 # Token verification examples
├── private.pem                       # RSA private key for JWT signing
├── pubkey.pem                        # RSA public key for JWT verification
├── Dockerfile                        # Container configuration
└── .env                              # Environment variables

APPLICATION FLOW:
-----------------

1. STARTUP SEQUENCE:
   main.go
   ├── Load .env file
   ├── Call setup()
   │   ├── setupDatabase()
   │   │   ├── postgres.OpenDb() - Connect to PostgreSQL with retry logic
   │   │   └── postgres.RunMigrations() - Run database migrations
   │   ├── users.NewConf(db) - Initialize user configuration with DB
   │   ├── Load RSA keys (private.pem, pubkey.pem)
   │   ├── auth.NewKeys() - Initialize JWT key manager
   │   ├── gin.New() - Create web server
   │   ├── handlers.RegisterRoutes() - Register API endpoints
   │   └── r.Run(":80") - Start server on port 80

2. API ENDPOINTS:
   GET  /ping                         # Health check endpoint
   POST /users/signup                 # User registration
   POST /users/login                  # User authentication
   GET  /users/onlyLoggedin          # Protected endpoint (placeholder)

3. USER REGISTRATION FLOW (/users/signup):
   HTTP Request (JSON: name, email, password, roles)
   ├── handlers.SignUp()
   │   ├── Parse & validate JSON request
   │   ├── Validate using struct tags & validator
   │   └── Call conf.InsertUser()
   │       ├── Generate UUID for user
   │       ├── Hash password using bcrypt
   │       ├── Start database transaction
   │       ├── Insert user into database
   │       └── Return User object (without password hash)
   └── Return HTTP 201 Created with user data

4. USER LOGIN FLOW (/users/login):
   HTTP Request (JSON: email, password)
   ├── handlers.Login()
   │   ├── Parse & validate JSON request
   │   ├── Call conf.AuthenticateUser()
   │   │   ├── Start database transaction
   │   │   ├── Query user by email
   │   │   ├── Compare password hash using bcrypt
   │   │   └── Return User object if valid
   │   ├── Create JWT Claims with user data
   │   │   ├── Set issuer: "user-service"
   │   │   ├── Set subject: user.ID
   │   │   ├── Set expiration: 1 hour from now
   │   │   └── Include user roles
   │   ├── Generate JWT token using RSA private key
   │   └── Return HTTP 200 OK with JWT token
   └── Client receives JWT for authenticated requests

DATABASE LAYER:
---------------
- Uses PostgreSQL with pgx driver
- Connection with retry logic
- Environment-based configuration:
  * POSTGRES_HOST, POSTGRES_PORT
  * POSTGRES_USER, POSTGRES_PASSWORD
  * POSTGRES_DATABASE
- Database migrations managed by Goose
- Transaction support for data consistency

AUTHENTICATION SYSTEM:
----------------------
- RSA-based JWT tokens (RS256 algorithm)
- Private key for signing tokens
- Public key for verifying tokens
- Custom Claims structure includes:
  * Standard JWT claims (issuer, subject, expiration)
  * User roles array
- Token expiration: 1 hour
- Password security: bcrypt hashing

DATA MODELS:
------------
User struct:
- ID (UUID string)
- Name (string)
- Email (string)
- PasswordHash (string, hidden from JSON)
- Roles (string array: "user" or "admin")
- CreatedAt (timestamp)
- UpdatedAt (timestamp)

NewUser struct (for registration):
- Name (required, 2-100 chars)
- Email (required, valid email)
- Password (required, min 5 chars)
- Roles (required, unique, must be "user" or "admin")

SECURITY FEATURES:
------------------
- Password hashing with bcrypt
- JWT token-based authentication
- RSA key pair for secure token signing/verification
- Input validation with struct tags
- SQL injection protection through parameterized queries
- Database transactions for data integrity

ERROR HANDLING:
---------------
- Structured logging with slog
- HTTP status codes for different error types
- Transaction rollback on failures
- Graceful error responses in JSON format
- Database connection retry mechanism

EXTERNAL DEPENDENCIES:
----------------------
- gin-gonic/gin: Web framework
- golang-jwt/jwt/v5: JWT token handling
- golang.org/x/crypto/bcrypt: Password hashing
- jackc/pgx/v5: PostgreSQL driver
- pressly/goose/v3: Database migrations
- go-playground/validator/v10: Input validation
- google/uuid: UUID generation
- joho/godotenv: Environment variable loading

DEPLOYMENT:
-----------
- Dockerized application
- Runs on port 80
- Requires RSA key pair files
- Environment-based configuration
- Can be part of microservices architecture

DEPENDENCY FLOW DIAGRAM:
========================

DEPENDENCY INJECTION HIERARCHY:
-------------------------------

main.go (Entry Point)
├── godotenv.Load(".env") ─────────────────────────→ Environment Variables
├── setup() ──────────────────────────────────────→ Application Setup
│   │
│   ├── setupDatabase() ──────────────────────────→ *sql.DB
│   │   ├── postgres.OpenDb() ────────────────────→ Database Connection
│   │   │   ├── Environment Variables ────────────→ Connection Config
│   │   │   │   ├── POSTGRES_HOST
│   │   │   │   ├── POSTGRES_PORT
│   │   │   │   ├── POSTGRES_USER
│   │   │   │   ├── POSTGRES_PASSWORD
│   │   │   │   └── POSTGRES_DATABASE
│   │   │   └── sql.Open(driverName, connString) ─→ *sql.DB
│   │   └── postgres.RunMigrations(db) ───────────→ Schema Setup
│   │
│   ├── users.NewConf(db) ────────────────────────→ *users.Conf
│   │   └── users.Conf{db: *sql.DB} ──────────────→ Database Layer Wrapper
│   │
│   ├── RSA Key Loading ──────────────────────────→ *auth.Keys
│   │   ├── os.ReadFile("private.pem") ───────────→ Private Key
│   │   ├── jwt.ParseRSAPrivateKeyFromPEM() ──────→ *rsa.PrivateKey
│   │   ├── os.ReadFile("pubkey.pem") ────────────→ Public Key
│   │   ├── jwt.ParseRSAPublicKeyFromPEM() ───────→ *rsa.PublicKey
│   │   └── auth.NewKeys(privateKey, publicKey) ──→ *auth.Keys
│   │
│   ├── gin.New() ────────────────────────────────→ *gin.Engine
│   │
│   └── handlers.RegisterRoutes(r, conf, k) ──────→ Route Setup
│       └── handlers.NewHandler(conf, k) ─────────→ *handlers.Handler
│           ├── conf *users.Conf ─────────────────→ Database Operations
│           └── k *auth.Keys ─────────────────────→ JWT Operations

DEPENDENCY FLOW THROUGH REQUEST HANDLERS:
------------------------------------------

HTTP Request → Gin Router → Handler Methods

1. SIGNUP FLOW DEPENDENCIES:
   handlers.Handler.SignUp(c *gin.Context)
   ├── h.conf *users.Conf ──────────────────────→ Database Operations
   │   ├── h.conf.InsertUser(ctx, newUser) ─────→ User Creation
   │   │   ├── h.conf.db *sql.DB ───────────────→ Database Connection
   │   │   ├── h.conf.withTx(ctx, fn) ──────────→ Transaction Management
   │   │   │   ├── h.conf.db.BeginTx(ctx, nil) ─→ Start Transaction
   │   │   │   ├── tx.QueryRowContext() ────────→ Execute Query
   │   │   │   └── tx.Commit() ─────────────────→ Commit Transaction
   │   │   └── bcrypt.GenerateFromPassword() ───→ Password Hashing
   │   └── Return User Object

2. LOGIN FLOW DEPENDENCIES:
   handlers.Handler.Login(c *gin.Context)
   ├── h.conf *users.Conf ──────────────────────→ User Authentication
   │   ├── h.conf.AuthenticateUser() ───────────→ User Verification
   │   │   ├── h.conf.db *sql.DB ───────────────→ Database Query
   │   │   ├── h.conf.withTx(ctx, fn) ──────────→ Transaction Management
   │   │   └── bcrypt.CompareHashAndPassword() ─→ Password Verification
   │   └── Return Authenticated User
   └── h.k *auth.Keys ───────────────────────────→ JWT Token Generation
       ├── h.k.GenerateToken(claims) ───────────→ Token Creation
       │   ├── jwt.NewWithClaims() ─────────────→ JWT Claims
       │   ├── h.k.privateKey *rsa.PrivateKey ──→ Token Signing
       │   └── tkn.SignedString() ──────────────→ Signed JWT Token
       └── Return JWT Token

DEPENDENCY RELATIONSHIPS:
-------------------------

*sql.DB (Database Connection)
├── Created in: main.setupDatabase()
├── Injected into: users.NewConf(db)
├── Used by: users.Conf methods
└── Purpose: Database operations, transactions

*users.Conf (User Business Logic)
├── Created in: main.setup() with users.NewConf(db)
├── Contains: *sql.DB dependency
├── Injected into: handlers.NewHandler(conf, k)
├── Used by: handlers.Handler methods
└── Purpose: User CRUD operations, authentication

*auth.Keys (JWT Authentication)
├── Created in: main.setup() with auth.NewKeys(privateKey, publicKey)
├── Contains: *rsa.PrivateKey, *rsa.PublicKey
├── Injected into: handlers.NewHandler(conf, k)
├── Used by: handlers.Handler.Login()
└── Purpose: JWT token generation and validation

*handlers.Handler (HTTP Request Handler)
├── Created in: handlers.RegisterRoutes() with handlers.NewHandler()
├── Contains: conf *users.Conf, k *auth.Keys
├── Used by: Gin route handlers
└── Purpose: HTTP request processing, business logic coordination


